//
// nrf24-low-power-sensor
//
// -+----I----+----I----+----I----+----I----+----I----+----I----+----I----+----I----+----I----+----I
//       10        20        30        40        50        60        70        80        90      100
// -+----I----+----I----+----I----+----I----+----I----+----I----+----I----+----I----+----I----+----I
//
// Example code for an ATmega328P processor conserving power by entering deep 
// sleep and later being woken up by an interrupt generated by an DS3231 RTC 
// in order to read and report sensor values using a NRF24L01 transceiver.
//
// To conserve power, the CPU enters deep sleep, and power for the sensors is
// disconnected via a 2N3904 transistor.
// 
// This template uses a DHT22 sensor to measure temperature and humidity.  See 
// the Fritzing sketches in the fritzing folder to easily modify the design for
// your particular usage.
//
// The code below contains debug statements printing information on the Arduino 
// IDE serial monitor. They can be removed by undefining the DEBUG_PRINT constant.
//
// Please refer to GitHub reposiotory for further details:
//   https://github.com/bjarne-hansen/nrf24-low-power-sensor
// 
// In order to get the current date/time when booting it used a simple setup with
// a Raspberry Pi server that publishes date/time information via a NRF24L01 
// transceiver.
//
// Please refer to the following pages on github for further details:
//   https://github.com/bjarne-hansen/nrf24-time-server
//   https://github.com/bjarne-hansen/nrf24-time-client
// 
// When date/time has been synchronised the program will go to sleep and be woken
// up every 15 minutes (configurable) to read sensor values and send collected data
// to a gateway via a NRF24L01 transceiver.
// 
// The gateway will take the binary payload, convert it to JSON and write it to a 
// file, publish it to MQTT or other actions defined in configuration.
//
// Please refer to the GitHub repository for the gateway for further details:
//   https://github.com/bjarne-hansen/nrf24-gateway
//

// "RF24" by TMRh20
//   https://tmrh20.github.io/RF24/
#include <printf.h>
#include <RF24.h>

// "Time" by Michael Margolis
//   https://playground.arduino.cc/Code/Time/
#include <time.h>

// "DS3232RTC" by Jack Christensen
//   https://github.com/JChristensen/DS3232RTC
#include <DS3232RTC.h>

// "Low-Power" by Rocket Scream Electronics
//   https://github.com/rocketscream/Low-Power
#include <LowPower.h>

// "DHT sensor library" by Adafruit
//   https://github.com/adafruit/DHT-sensor-library
#include <DHT.h>
#include <DHT_U.h>

// "Battery Sense" by AgileWare
//   https://github.com/rlogiacco/BatterySense
#include <Battery.h>

// Enable/disable debugging output on serial.
#define DEBUG_PRINT
#undef  DEBUG_NRF24

#define PIN_INT       2       // PIN used for interrupt. INT0 on an Arduino.  
#define PIN_RELAY     4       // PIN used for 2N3904 "relay" for turning on/off power to sensors.
#define PIN_DHT       5       // PIN for accessing DHT sensor. 
#define PIN_LED       8       // PIN controlling LED.
#define PIN_RF24_CSN  9       // CSN PIN for RF24 module.
#define PIN_RF24_CE  10       // CE PIN for RF24 module.

#define PIN_SENSE    A1       // Analog PIN for reading battery voltage.


#define NRF24_CHANNEL         100           // 0 ... 125
#define NRF24_CRC_LENGTH      RF24_CRC_16   // RF24_CRC_DISABLED, RF24_CRC_8, RF24_CRC_16 for 16-bit
#define NRF24_DATA_RATE       RF24_250KBPS  // RF24_2MBPS, RF24_1MBPS, RF24_250KBPS
#define NRF24_PAYLOAD_SIZE    32            // Max. 32 bytes.

#define NRF24_PA_LEVEL        RF24_PA_MAX   // RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX    
#define NRF24_RETRY_DELAY     5             // Delay bewteen retries, 1..15.  Multiples of 250µs.
#define NRF24_RETRY_COUNT     15            // Number of retries, 1..15.


RF24 radio(PIN_RF24_CE, PIN_RF24_CSN);  // NRF24L01 radio.

byte sensor_tx_addr[6] = "1LD57";       // Transmission address for readings.
byte time_rx_addr[6] = "DTCLI";         // Reception address for date/time.
byte payload[32];

byte protocol = 0x01;                   // Protocol 0x01: protocol, reading, voltage, temperature, humidity.
unsigned int reading = 0;               // Count of consequtive readings.

DHT dht(PIN_DHT, DHT22);                // DHT temperature and humidity sensor.

// Min. voltage, max. voltage, analog pin for sensing.
Battery battery = Battery(1800, 3300, PIN_SENSE);  

void setup() 
{
  // Initialise all components.
  debug_begin();  
  debug_println("\n\nnrf24-low-power-sensor.");

  // Count the number of consequtive reads after sensor has booted.
  // Helps identify if the sensor is spontaniously resetting.
  reading = 0;

  // Initialise LED.
  debug_println("- LED ...");
  pinMode(PIN_LED, OUTPUT);         // LED PIN is output.
  digitalWrite(PIN_LED, LOW);       // Turn off LED.

  // Flash the LED 3 senconds. 
  // 3 long on, short off, to signal we are booting.
  flash_led(3, 800, 200);

  // Initialise the "relay" that turns power to sesors on/off.
  debug_println("- RELAY ...");
  pinMode(PIN_RELAY, OUTPUT);       // RELAY PIN in output.
  digitalWrite(PIN_RELAY, HIGH);    // Initialise relay to on.

  // Initialise the DHT temperature and humidity sensor
  debug_println("- DHT ...");
  dht.begin();

  // Initialise interrupt allowing the RTC to wake us up.
  debug_println("- INTERRUPT ...");
  pinMode(PIN_INT, INPUT_PULLUP);   
  digitalWrite(PIN_INT, HIGH);      
  attachInterrupt(digitalPinToInterrupt(PIN_INT), wake, FALLING);  

  // Initialise RTC.
  debug_println("- RTC ...");
  rtc_setup();

  // Start the NRF24 module.
  debug_println("- NRF24 ...");
  nrf24_setup();
  #ifdef DEBUG_NRF24
  debug_nrf24_details(radio);
  #endif
  
  // Receive current date/time via NRF24L01.
  debug_println("- NRF24 (date/time) ...");
  nrf24_receive_date_time();
  debug_print("  ");
  debug_println(RTC.get());
  
  // Initialize battery with ref. voltage and divider ratio.
  // Please refer to https://github.com/rlogiacco/BatterySense for information on calculating
  // the correct divider ration.  Here we have two 1K ohm resistors giving a ratio of 2.00.
  debug_println("- BATTERY ...");
  battery.begin(3300, 2.00);

  // Set next alarm.
  debug_println("- RTC (next alarm) ...");
  rtc_set_next_alarm();

  // Flash led for 3 seconds.
  // 3 long off, short on, to signal we are booting.
  flash_led(3, 200, 800);
}


void loop() 
{
  // Tell that we are going to take a nap.
  debug_println("Going to sleep.");
  
  // Delay to make sure we see message before CPU goes to sleep.
  delay(50); 

  // Power down radio and sensors, before we go to sleep ...
  radio.powerDown();
  digitalWrite(PIN_RELAY, LOW);

  // Enter deep sleep ...
  LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);

  // After RTC generates interrupt, processing will continue here.
  debug_println("Awake!");

  if (RTC.alarm(ALARM_1))
  {
    // Print current date/time.
    debug_println(RTC.get());

    // Power up radio and sensors.
    radio.powerUp();
    
    digitalWrite(PIN_RELAY, HIGH);
    delay(2000);
    
    // Read sensors and send values via NRF24L01.
    read_sensors();
    
    // Set next alarm.
    rtc_set_next_alarm();
  }
  else
    debug_println("Unsolicited interrupt.");
}

void wake()
{
  debug_println("Interrupt.");  
}

void read_sensors()
{
  int offset = 0;
  unsigned int vcc = 0;
  float t, h;
  
  // Turn on LED.
  digitalWrite(PIN_LED, HIGH);

  // Read sensors.
  reading++;
  t = dht.readTemperature();
  h = dht.readHumidity();
  vcc = battery.voltage();

  // Print sensor values.
  debug_print("Reading: "); debug_println(reading);
  debug_print("Humidity: "); debug_println(h);
  debug_print("Temperature: "); debug_println(t);
  debug_print("Voltage: "); debug_println(vcc);
 
  // Pack payload with data.
  debug_print("Preparing payload: "); debug_println(reading);
  memcpy(payload + offset, (byte *)(&protocol), sizeof(protocol)); offset += sizeof(protocol);
  memcpy(payload + offset, (byte *)(&reading), sizeof(reading)); offset += sizeof(reading);
  memcpy(payload + offset, (byte *)(&vcc), sizeof(vcc)); offset += sizeof(vcc);
  memcpy(payload + offset, (byte *)(&t), sizeof(t)); offset += sizeof(t);
  memcpy(payload + offset, (byte *)(&h), sizeof(h)); offset += sizeof(h);
  debug_print("Bytes packed: "); debug_println(offset);

  // Send payload.
  int rc = nrf24_send(payload, offset, 5);
  digitalWrite(PIN_LED, LOW);
  if (rc > -1)
  {
    debug_print("Payload sent. Retries="); debug_println(rc);    
    delay(500);
  }
  else
  {
    debug_println("Failed to send payload.");
    flash_led(10, 50);
  }
}



//
// NRF24L01 functions
//

int nrf24_send(byte *buf, int bytes, int retries)
{
  int max_retries = retries;
  
  while (retries > 0)
  {
    delay((5 - retries) * 50);      // 0, 50, 100, 150, 200 (max. 500ms)
    if (radio.write(payload, bytes))
      break;
    retries--;      
  }

  if (retries == 0)
    return -1;
  else
    return max_retries - retries;
}

boolean nrf24_receive(int timeout)
{
  unsigned long started;
  boolean timed_out;
  boolean result;
  
  radio.startListening();
    
  // Check if data is available, or  we pass the timeout.
  timed_out = false;
  started = millis();
  while (!radio.available())
  {
    if (millis() - started > timeout)
    {
      timed_out = true;
      break;
    }
  }

  if (!timed_out)
  {
    // Data available ... read it ...
    radio.read(&payload, sizeof(payload));
    result = true;
  }
  else
    result = false;   

  radio.stopListening();
  return result;
}

void nrf24_setup()
{

  
#define NRF24_CHANNEL         100           // 0 ... 125
#define NRF24_CRC_LENGTH      RF24_CRC_16   // RF24_CRC_DISABLED, RF24_CRC_8, RF24_CRC_16 for 16-bit
#define NRF24_DATA_RATE       RF24_250KBPS  // RF24_2MBPS, RF24_1MBPS, RF24_250KBPS
#define NRF24_PAYLOAD_SIZE    32            // Max. 32 bytes.

#define NRF24_PA_LEVEL        RF24_PA_MAX   // RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX    
#define NRF24_RETRY_DELAY     5             // Delay bewteen retries, 1..15.  Multiples of 250µs.
#define NRF24_RETRY_COUNT     15            // Number of retries, 1..15.


  radio.begin();
  radio.setChannel(NRF24_CHANNEL);
  radio.setCRCLength(NRF24_CRC_LENGTH);
  radio.setDataRate(NRF24_DATA_RATE);        
  radio.setPayloadSize(NRF24_PAYLOAD_SIZE);
  radio.setPALevel(NRF24_PA_LEVEL);
  radio.setRetries(NRF24_RETRY_DELAY, NRF24_RETRY_COUNT);              
  
  radio.setAutoAck(true);                 // Automatic ack.   
  radio.enableDynamicPayloads();          // Payload size is dynamic.
  
  radio.openWritingPipe(sensor_tx_addr);  // Send to address.
  radio.openReadingPipe(1, time_rx_addr); // Receive date/time on pipe 1.  
  radio.stopListening();                  
}

void nrf24_receive_date_time()
{
  unsigned int count = 0;
  debug_print("  ");
  while (true)
  {
    if (nrf24_receive(1000))
    {
      if (rtc_set_time_from_payload())
      {
        debug_print('+');
        break;
      }
      else
      {
        debug_print('-');  
        flash_led(5, 10, 10);
      }
    }
    else
    {
      debug_print('.');
      flash_led(1, 50, 50);
    }
    count++;
    if (count == 30)
    {
      debug_println();
      debug_print("  ");
      count = 0;
    }
  }
  debug_println();
}



//
// RTC functions
//

void rtc_setup()
{
  RTC.setAlarm(ALM1_MATCH_DATE, 0, 0, 0, 1);
  RTC.setAlarm(ALM2_MATCH_DATE, 0, 0, 0, 1);
  RTC.alarm(ALARM_1);
  RTC.alarm(ALARM_2);
  RTC.alarmInterrupt(ALARM_1, false);
  RTC.alarmInterrupt(ALARM_2, false);
  RTC.squareWave(SQWAVE_NONE);
}

boolean rtc_set_time_from_payload()
{

  tmElements_t tm;
  time_t result;

  // Check the signature 0xfe followed by "TIME" (0x54, 0x49, 0x4d, 0x45)
  if (payload[0] == 0xfe && payload[1] == 0x54 && payload[2] == 0x49 && payload[3] == 0x4d && payload[4] == 0x45) 
  {
    
    // Extract date/time data from payload.
    tm.Year = (payload[6] << 8 | payload[5]) - 1970;
    tm.Month = payload[7];
    tm.Day = payload[8];
    tm.Hour = payload[9];
    tm.Minute = payload[10];
    tm.Second = payload[11];
    tm.Wday = payload[12] % 7 + 1;
    
    // Create time_t structure from date/time elements.
    result = makeTime(tm);

    // Update the RTC clock with date/time.
    RTC.set(result);
    
    return true;
  }
  else
  {
    return false;
  }
}

void rtc_set_next_alarm()
{
    int nm, ns;

    // Get next minute and seconds;
    nm = rtc_next_minute();
    ns = rtc_next_second();

    // Print time for next alarm being triggered.
    debug_print("Next alarm: *:"); 
    debug_print(nm < 10 ? "0": ""); debug_print(nm); debug_print(":"); 
    debug_print(ns < 10 ? "0": ""); debug_print(ns); 
    debug_println();

    // Set the alarm on the RTC.
    RTC.setAlarm(ALM1_MATCH_MINUTES, ns, nm, 0, 1);
    RTC.alarmInterrupt(ALARM_1, true);    
}

int rtc_next_minute()
{  
  time_t dt;
  int m, nm;

  // Get time from RTC.
  dt = RTC.get();

  // Extract current minute.
  m = minute(dt);

  // Calculate next minute.
  nm = ((int)((m + 1)/1.0 + 0.5)) % 60 * 1 - 1;       // Every 1 minute
  // nm = ((int)((m + 2)/2.0 + 0.5)) % 30 * 2 - 1;    // Every 2 minutes
  // nm = ((int)((m + 3)/3.0 + 0.5)) % 20 * 3 - 1;    // Every 3 minutes
  // nm = ((int)((m + 4)/4.0 + 0.5)) % 15 * 4 - 1;    // Every 2 minutes
  // nm = ((int)((m + 5)/5.0 + 0.5)) % 12 * 5 - 1;    // Every 5 minutes
  // nm = ((int)((m + 6)/6.0 + 0.5)) % 10 * 5 - 1;    // Every 6 minutes
  // nm = ((int)((m + 10)/10.0 + 0.5)) % 6 * 10 - 1;  // Every 10 minutes
  // nm = ((int)((m + 15)/15.0 + 0.5)) % 4 * 15 - 1;  // Every 15 minutes
  // nm = ((int)((m + 30)/30.0 + 0.5)) % 2 * 30 - 1;  // Every 30 minutes

  // Return next minute.
  return nm >= 0 ? nm : 60 + nm;
}

int rtc_next_second()
{
  // Always set the alarm 2 seconds before the minute to allow
  // us to read sensors and send values on the next minute.
  return 58;  
}



//
// Utilities for flashing LED.
//

void flash_led(int count, int ms)
{
  for (int i = 0; i < count; i++)
  {
    digitalWrite(PIN_LED, HIGH);
    delay(ms);
    digitalWrite(PIN_LED, LOW);
    delay(ms);      
  }  
}

void flash_led(int count, int onms, int offms)
{
  for (int i = 0; i < count; i++)
  {
    digitalWrite(PIN_LED, HIGH);
    delay(onms);
    digitalWrite(PIN_LED, LOW);
    delay(offms);      
  }    
}



//
// Functions for debugging low-power NRF24L01 solutions.
//

void debug_begin()
{
  #ifdef DEBUG_PRINT
  Serial.begin(9600);
  #endif
  #ifdef __PRINTF_H__
  printf_begin();
  #endif
  
}

void debug_print(byte n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}

void debug_print(char n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}

void debug_print(short n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}

void debug_print(int n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}

void debug_print(unsigned int n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}

void debug_print(long n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}


void debug_print(float n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}

void debug_print(double n)
{
  #ifdef DEBUG_PRINT
  Serial.print(n);
  #endif
}

void debug_print(const char* s)
{
  #ifdef DEBUG_PRINT
  Serial.print(s);
  #endif    
}

void debug_println()
{
  #ifdef DEBUG_PRINT
  Serial.println();
  #endif  
}

void debug_println(byte n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(char n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(short n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(int n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(unsigned int n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(long n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(float n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(double n)
{
  #ifdef DEBUG_PRINT
  Serial.println(n);
  #endif    
}

void debug_println(const char* s)
{
  #ifdef DEBUG_PRINT
  Serial.println(s);
  #endif  
}

#ifdef __RF24_H__
void debug_nrf24_details(RF24 r)
{
  #ifdef __PRINTF_H__
  r.printDetails();
  #endif
}
#endif

#ifdef _Time_h
void debug_print(time_t t)
{
    // Print year-month-day.
    debug_print(year(t)); debug_print("-");
    debug_print(month(t) < 10 ? "0" : ""); debug_print(month(t)); debug_print("-");
    debug_print(day(t) < 10 ? "0" : ""); debug_print(day(t)); 

    debug_print(" ");
    
    // Print time.
    debug_print(hour(t) < 10 ? "0" : ""); debug_print(hour(t)); debug_print(':');
    debug_print(minute(t) < 10 ? "0" : ""); debug_print(minute(t)); debug_print(':');
    debug_print(second(t) < 10 ? "0" : ""); debug_print(second(t));    
}

void debug_println(time_t t)
{
  debug_print(t);
  debug_println();
}
#endif
